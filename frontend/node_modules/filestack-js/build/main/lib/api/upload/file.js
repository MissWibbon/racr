"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_1 = require("./../../utils");
/**
 * File representation to unify file object in nodejs and browser
 *
 * @export
 * @class File
 */
var File = /** @class */ (function () {
    function File(_file, _sanitizeOptions) {
        this._file = _file;
        this._sanitizeOptions = _sanitizeOptions;
        this._file.name = utils_1.sanitizeName(this._file.name, this._sanitizeOptions);
    }
    Object.defineProperty(File.prototype, "name", {
        /**
         * Returns file name
         *
         * @returns {string}
         * @memberof File
         */
        get: function () {
            return this._file.name;
        },
        /**
         * Sets new file name  and cleanup extra chars
         *
         * @memberof File
         */
        set: function (val) {
            this._file.name = utils_1.sanitizeName(val, this._sanitizeOptions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "filename", {
        /**
         * Alias for name getter
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "customName", {
        /**
         * Sets custom name using string or function
         * Name will be sanitized
         *
         * @memberof File
         */
        set: function (val) {
            switch (typeof val) {
                case 'string':
                    this.name = val;
                    break;
                case 'function':
                    var newName = val(this);
                    if (typeof newName !== 'string') {
                        throw new Error("Name function must return a string. Current return type is " + typeof val);
                    }
                    this.name = val(this);
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "type", {
        /**
         * Returns file type
         *
         * @default 'application/octet-stream'
         * @returns {string}
         * @memberof File
         */
        get: function () {
            /* istanbul ignore next */
            return this._file.type || 'application/octet-stream';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "mimetype", {
        /**
         * Alias for file type
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "size", {
        /**
         * Returns file size
         *
         * @returns {number}
         * @memberof File
         */
        get: function () {
            return this._file.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns number of parts according to part size
     *
     * @param {number} size - part size in bytes
     * @returns {number}
     * @memberof File
     */
    File.prototype.getPartsCount = function (size) {
        return Math.ceil(this._file.size / size);
    };
    /**
     * Returns part metadata
     *
     * @param {number} [partNum=0]
     * @param {*} size
     * @returns {FilePartMetadata}
     * @memberof File
     */
    File.prototype.getPartMetadata = function (partNum, size) {
        var startByte = size * partNum;
        if (startByte > this._file.size) {
            throw new Error("Start byte of the part is higher than buffer size");
        }
        var endByte = Math.min(startByte + size, this._file.size);
        return {
            partNumber: partNum,
            startByte: startByte,
            endByte: endByte,
            size: endByte - startByte,
        };
    };
    /**
     * Returns part metadata + buffer
     *
     * @param {FilePartMetadata} meta
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getPartByMetadata = function (meta, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var slice;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._file.slice(meta.startByte, meta.endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(tslib_1.__assign({}, meta, { buffer: slice, md5: md5Enabled ? utils_1.md5(slice) : undefined }))];
                }
            });
        });
    };
    /**
     * Returns part chunk
     *
     * @param {FilePartMetadata} meta
     * @param {number} offset
     * @param {number} chunkSize
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getChunkByMetadata = function (meta, offset, chunkSize, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var startByte, endByte, slice;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startByte = meta.startByte + offset;
                        endByte = Math.min(startByte + chunkSize, meta.endByte);
                        return [4 /*yield*/, this._file.slice(startByte, endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(tslib_1.__assign({}, meta, { buffer: slice, md5: md5Enabled ? utils_1.md5(slice) : undefined, size: slice.byteLength, startByte: startByte,
                                endByte: endByte,
                                offset: offset }))];
                }
            });
        });
    };
    /**
     * Cleanup file buffer to release memory
     *
     * @memberof File
     */
    File.prototype.release = function () {
        if (this._file.release) {
            this._file.release();
        }
    };
    File.prototype.toJSON = function () {
        return {
            name: this.name,
            status: this.status,
            type: this.type,
            size: this.size,
            url: this.url,
            handle: this.handle,
        };
    };
    return File;
}());
exports.File = File;
