"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var file_1 = require("./file");
var utils_1 = require("./../../utils");
var filestack_error_1 = require("./../../../filestack_error");
var file_type_1 = require("file-type");
var base64Regexp = /data:([a-zA-Z]*\/[a-zA-Z]*);base64,([^\"]*)/i;
/**
 * Check if file is buffer
 *
 * @node
 * @param input
 */
var isFileBuffer = function (input) { return Buffer.isBuffer(input); };
/**
 * Check if file is blob
 * @param input
 */
var isFileBlob = function (input) { return input.toString() === '[object Blob]'; };
/**
 * Check if input is instance of browser file
 *
 * @browser
 * @param input
 */
var isFileBrowser = function (input) { return input instanceof File; };
/**
 * Check if file is base64 string
 *
 * @param input
 */
var isFileBase = function (input) {
    if (typeof input !== 'string') {
        return false;
    }
    if (input.indexOf('base64') > -1) {
        input = input.match(base64Regexp).pop();
    }
    if (utils_1.isNode()) {
        if (Buffer.from(input, 'base64').toString('base64') === input) {
            return true;
        }
        return false;
    }
    try {
        return btoa(atob(input)) === input;
    }
    catch (err) {
        /* istanbul ignore next */
        return false;
    }
};
/**
 * Check if file is instance of named interface
 *
 * @param input
 */
var isFileNamed = function (input) { return input && input['file'] && input['name']; };
/**
 * Check if input is a valid file path
 *
 * @node
 * @param input
 */
var isFilePath = function (input) { return utils_1.requireNode('fs').existsSync(input); };
/**
 * Convert encoded base64 string or dataURI to blob
 *
 * @browser
 * @param b64data     String to decode
 * @param sliceSize   Byte quantity to split data into
 * @private
 * @returns {Blob}
 */
var b64toBlob = function (b64Data, sliceSize) {
    if (sliceSize === void 0) { sliceSize = 512; }
    var contentType = '';
    if (b64Data.indexOf('base64') > -1) {
        var matches = b64Data.match(base64Regexp);
        b64Data = matches.pop();
        contentType = matches[1];
    }
    var byteCharacters = atob(b64Data);
    var byteArrays = [];
    for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        var slice = byteCharacters.slice(offset, offset + sliceSize);
        var byteNumbers = new Array(slice.length);
        for (var i = 0; i < slice.length; i += 1) {
            byteNumbers[i] = slice.charCodeAt(i);
        }
        byteArrays.push(new Uint8Array(byteNumbers));
    }
    return new Blob(byteArrays, { type: contentType });
};
/**
 * Read file as array buffer
 *
 * @browser
 * @private
 * @param blob
 * @returns {Boolean}
 */
var readFile = function (file) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        /* istanbul ignore next */
        if (!File || !FileReader || !Blob) {
            return [2 /*return*/, Promise.reject(new filestack_error_1.FilestackError('The File APIs are not fully supported by your browser'))];
        }
        return [2 /*return*/, Promise.resolve({
                slice: function (start, end) {
                    return readPart(start, end, file);
                },
                release: function () {
                    file = null;
                },
            })];
    });
}); };
/**
 * Read file par instead of whole file to avoid browser crashing
 *
 * @param start - star byte
 * @param end  - end byte
 * @param file - file to slice
 */
var readPart = function (start, end, file) {
    return new Promise(function (resolve, reject) {
        var r = new FileReader();
        var blob = file.slice(start, end);
        r.onload = function () { return resolve(r.result); };
        r.onerror = reject;
        r.readAsArrayBuffer(blob);
    });
};
// =================== BROWSER UTILS ===================
/**
 * Accepts b64string or blob file
 *
 * @browser
 * @param {*} fileOrString
 * @returns {Promise<File>}
 */
var getFileBrowser = function (input, sanitizeOptions) {
    var filename;
    var file;
    if (isFileNamed(input)) {
        filename = input.name;
        input = input.file;
    }
    if (isFileBrowser(input)) {
        file = input;
        filename = input.name;
    }
    else if (isFileBase(input)) {
        file = b64toBlob(input);
    }
    else if (isFileBlob(input)) {
        file = input;
    }
    else {
        return Promise.reject(new filestack_error_1.FilestackError('Unsupported input file type'));
    }
    return readFile(file).then(function (res) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var mime, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    mime = file.type;
                    if (!!file.type) return [3 /*break*/, 2];
                    _a = utils_1.getMimetype;
                    return [4 /*yield*/, res.slice(0, file_type_1.default.minimumBytes)];
                case 1:
                    mime = _a.apply(void 0, [_b.sent(), filename]);
                    _b.label = 2;
                case 2: return [2 /*return*/, new file_1.File({
                        name: filename,
                        size: file.size,
                        type: mime,
                        slice: res.slice,
                        release: res.release,
                    }, sanitizeOptions)];
            }
        });
    }); });
};
// =================== NODE UTILS ===================
/**
 * Accepts Buffer or filepath or base64 string
 *
 * @node
 * @param {*} inputFile
 * @returns {Promise<File>}
 */
var getFileNode = function (input, sanitizeOptions) {
    var filename;
    if (isFileNamed(input)) {
        filename = input.name;
        input = input.file;
    }
    if (isFilePath(input)) {
        var path_1 = input;
        // @todo improve slicer open file and read it py by part
        return new Promise(function (resolve, reject) {
            return utils_1.requireNode('fs').readFile(path_1, function (err, buffer) {
                if (err) {
                    return reject(err);
                }
                if (!filename) {
                    filename = utils_1.requireNode('path').basename(path_1);
                }
                return resolve(new file_1.File({
                    name: filename,
                    size: buffer.byteLength,
                    type: utils_1.getMimetype(buffer, filename),
                    slice: function (start, end) { return Promise.resolve(buffer.slice(start, end)); },
                }, sanitizeOptions));
            });
        });
    }
    if (isFileBase(input)) {
        input = Buffer.from(input, 'base64');
    }
    if (isFileBuffer(input)) {
        return Promise.resolve(new file_1.File({
            name: filename,
            size: input.byteLength,
            type: utils_1.getMimetype(input, filename),
            // @ts-ignore
            slice: function (start, end) { return Promise.resolve(input.slice(start, end)); },
        }, sanitizeOptions));
    }
    return Promise.reject(new filestack_error_1.FilestackError('Unsupported input file type'));
};
exports.getFile = function (input, sanitizeOptions) { return (utils_1.isNode() ? getFileNode(input, sanitizeOptions) : getFileBrowser(input, sanitizeOptions)); };
