var _this = this;
import * as tslib_1 from "tslib";
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { getFile } from './file_tools';
import * as fs from 'fs';
jest.mock('fs');
var mockedTestFile = Buffer.from('text text');
var base64Svg = 'PHN2ZyBoZWlnaHQ9IjEwMCIgd2lkdGg9IjEwMCI+CiAgPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMyIgZmlsbD0icmVkIiAvPgogIFNvcnJ5LCB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBpbmxpbmUgU1ZHLiAgCjwvc3ZnPiA=';
describe('Api/Upload/FileTools', function () {
    describe('getFileNode', function () {
        it('Should return file instance for nodejs loaded file from path', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var file, meta, slice;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spyOn(fs, 'existsSync').and.returnValue(true);
                        spyOn(fs, 'readFile').and.callFake(function (path, cb) {
                            cb(null, mockedTestFile);
                        });
                        return [4 /*yield*/, getFile('/testfile.txt')];
                    case 1:
                        file = _a.sent();
                        expect(file.name).toEqual('testfile.txt');
                        expect(file.mimetype).toEqual('text/plain');
                        expect(file.size).toEqual(9);
                        meta = file.getPartMetadata(0, 2);
                        return [4 /*yield*/, file.getPartByMetadata(meta)];
                    case 2:
                        slice = _a.sent();
                        expect(slice.size).toEqual(2);
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should reject if provided file cannot be read', function () {
            spyOn(fs, 'existsSync').and.returnValue(true);
            spyOn(fs, 'readFile').and.callFake(function (path, cb) {
                cb('error');
            });
            return expect(getFile('/testfile.txt')).rejects.toEqual('error');
        });
        it('Should return correct mimetype', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var file;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        jest.unmock('fs');
                        return [4 /*yield*/, getFile('./package.json')];
                    case 1:
                        file = _a.sent();
                        expect(file.mimetype).toEqual('application/json');
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should return correct file instance from buffer', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var file;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getFile(mockedTestFile)];
                    case 1:
                        file = _a.sent();
                        expect(file.size).toEqual(9);
                        expect(file.mimetype).toEqual('text/plain');
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should handle base64 encoded string', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var file;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getFile({
                            name: 'test.svg',
                            file: base64Svg,
                        })];
                    case 1:
                        file = _a.sent();
                        expect(file.mimetype).toEqual('image/svg+xml');
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should detect text/plain mimetype', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var file;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getFile({
                            name: 'test.undefined',
                            file: base64Svg,
                        })];
                    case 1:
                        file = _a.sent();
                        expect(file.mimetype).toEqual('text/plain');
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should get part of the buffer after slice', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var file, meta, slice;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getFile(mockedTestFile)];
                    case 1:
                        file = _a.sent();
                        meta = file.getPartMetadata(0, 2);
                        return [4 /*yield*/, file.getPartByMetadata(meta)];
                    case 2:
                        slice = _a.sent();
                        expect(slice.size).toEqual(2);
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should handle base64 encoded string', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var file;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getFile({
                            name: 'test.undefined',
                            file: Buffer.of(12),
                        })];
                    case 1:
                        file = _a.sent();
                        expect(file.mimetype).toEqual('text/plain');
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should throw error when random string is provided', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, expect(getFile('asdasdfasdf')).rejects.toEqual(new Error('Unsupported input file type'))];
            });
        }); });
        it('Should pass sanitize options to file instance (buffer)', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fileRes;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getFile({
                            file: mockedTestFile,
                            name: 'test<.jpg',
                        }, {
                            replacement: '=',
                        })];
                    case 1:
                        fileRes = _a.sent();
                        expect(fileRes.name).toEqual('test=.jpg');
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should pass sanitize options to file instance path', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fileRes;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getFile({
                            file: './package.json',
                            name: 'test<.jpg',
                        }, {
                            replacement: '=',
                        })];
                    case 1:
                        fileRes = _a.sent();
                        expect(fileRes.name).toEqual('test=.jpg');
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should handle named file input', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var file;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getFile({
                            name: '123.jpg',
                            file: mockedTestFile,
                        })];
                    case 1:
                        file = _a.sent();
                        expect(file.name).toEqual('123.jpg');
                        expect(file.size).toEqual(9);
                        expect(file.mimetype).toEqual('image/jpeg');
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should reject on unsupported input file type', function () {
            // @ts-ignore
            return expect(getFile({})).rejects.toEqual(new Error('Unsupported input file type'));
        });
    });
});
