/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as tslib_1 from "tslib";
import { request } from './request';
import { removeEmpty } from '../utils';
import { FilestackError } from './../../filestack_error';
import { getValidator, MetadataParamsSchema, RetrieveParamsSchema } from './../../schema';
/**
 * Remove given file
 *
 * @private
 * @param session
 * @param handle
 * @param security
 */
export var remove = function (session, handle, skipStorage, security) {
    if (!handle || typeof handle !== 'string') {
        throw new FilestackError('A valid Filestack handle is required for remove');
    }
    if (!(session.policy && session.signature) && (!security || !(security.policy && security.signature))) {
        throw new FilestackError('Security policy and signature are required for remove');
    }
    var fileApiUrl = session.urls.fileApiUrl;
    var baseURL = fileApiUrl + "/" + handle;
    var options = {
        key: session.apikey,
        policy: (security && security.policy) || session.policy,
        signature: (security && security.signature) || session.signature,
    };
    if (skipStorage) {
        options.skip_storage = true;
    }
    return request.delete(baseURL, {
        params: removeEmpty(options),
    });
};
/**
 * Returns file metadata
 *
 * @private
 * @param session
 * @param handle
 * @param opts
 * @param security
 */
export var metadata = function (session, handle, opts, security) {
    if (!handle || typeof handle !== 'string') {
        throw new FilestackError('A valid Filestack handle is required for metadata');
    }
    var validateRes = getValidator(MetadataParamsSchema)(opts);
    if (validateRes.errors.length) {
        throw new FilestackError("Invalid metadata params", validateRes.errors);
    }
    var options = tslib_1.__assign({}, opts);
    options.source_url = options.sourceUrl; // source_url is snake_case
    options.policy = (security && security.policy) || session.policy;
    options.signature = (security && security.signature) || session.signature;
    var baseURL = session.urls.fileApiUrl + "/" + handle + "/metadata";
    return new Promise(function (resolve, reject) {
        request
            .get(baseURL, { params: removeEmpty(options) })
            .then(function (res) { return resolve(tslib_1.__assign({}, res.data, { handle: handle })); })
            .catch(reject);
    });
};
/**
 * @private
 */
var ERequestMethod;
(function (ERequestMethod) {
    ERequestMethod["get"] = "get";
    ERequestMethod["head"] = "head";
})(ERequestMethod || (ERequestMethod = {}));
/**
 * @private
 */
var EResponseType;
(function (EResponseType) {
    EResponseType["blob"] = "blob";
    EResponseType["json"] = "json";
})(EResponseType || (EResponseType = {}));
/**
 * Returns file information
 *
 * @private
 * @param session
 * @param handle
 * @param options
 * @param security
 */
export var retrieve = function (session, handle, options, security) {
    if (options === void 0) { options = {}; }
    if (!handle || handle.length === 0 || typeof handle !== 'string') {
        throw new FilestackError('File handle is required');
    }
    var validateRes = getValidator(RetrieveParamsSchema)(options);
    if (validateRes.errors.length) {
        throw new FilestackError("Invalid retrieve params", validateRes.errors);
    }
    var requestOptions = tslib_1.__assign({}, options);
    requestOptions.key = session.apikey;
    requestOptions.policy = (security && security.policy) || session.policy;
    requestOptions.signature = (security && security.signature) || session.signature;
    var method = ERequestMethod.get;
    if (requestOptions.head) {
        method = ERequestMethod.head;
        delete requestOptions.head;
    }
    var extension;
    if (requestOptions.extension && requestOptions.extension.length) {
        extension = requestOptions.extension;
        delete requestOptions.extension;
    }
    var metadata;
    if (requestOptions.metadata) {
        if (method === ERequestMethod.head) {
            throw new FilestackError('Head and metadata options cannot be used together');
        }
        metadata = requestOptions.metadata;
        delete requestOptions.metadata;
    }
    var baseURL = session.urls.fileApiUrl + "/" + handle + (extension ? "+" + extension : '') + (metadata ? '/metadata' : '');
    return new Promise(function (resolve, reject) {
        request({
            url: baseURL,
            method: method,
            params: removeEmpty(requestOptions),
        })
            .then(function (res) { return resolve(method === ERequestMethod.head ? res.headers : res.data); })
            .catch(reject);
    });
};
