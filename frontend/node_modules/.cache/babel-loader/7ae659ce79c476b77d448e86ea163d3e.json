{"ast":null,"code":"'use strict';\n\nvar uri = require('url');\n\nvar ValidationError = exports.ValidationError = function ValidationError(message, instance, schema, propertyPath, name, argument) {\n  if (propertyPath) {\n    this.property = propertyPath;\n  }\n\n  if (message) {\n    this.message = message;\n  }\n\n  if (schema) {\n    if (schema.id) {\n      this.schema = schema.id;\n    } else {\n      this.schema = schema;\n    }\n  }\n\n  if (instance) {\n    this.instance = instance;\n  }\n\n  this.name = name;\n  this.argument = argument;\n  this.stack = this.toString();\n};\n\nValidationError.prototype.toString = function toString() {\n  return this.property + ' ' + this.message;\n};\n\nvar ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {\n  this.instance = instance;\n  this.schema = schema;\n  this.propertyPath = ctx.propertyPath;\n  this.errors = [];\n  this.throwError = options && options.throwError;\n  this.disableFormat = options && options.disableFormat === true;\n};\n\nValidatorResult.prototype.addError = function addError(detail) {\n  var err;\n\n  if (typeof detail == 'string') {\n    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);\n  } else {\n    if (!detail) throw new Error('Missing error detail');\n    if (!detail.message) throw new Error('Missing error message');\n    if (!detail.name) throw new Error('Missing validator type');\n    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);\n  }\n\n  if (this.throwError) {\n    throw err;\n  }\n\n  this.errors.push(err);\n  return err;\n};\n\nValidatorResult.prototype.importErrors = function importErrors(res) {\n  if (typeof res == 'string' || res && res.validatorType) {\n    this.addError(res);\n  } else if (res && res.errors) {\n    Array.prototype.push.apply(this.errors, res.errors);\n  }\n};\n\nfunction stringizer(v, i) {\n  return i + ': ' + v.toString() + '\\n';\n}\n\nValidatorResult.prototype.toString = function toString(res) {\n  return this.errors.map(stringizer).join('');\n};\n\nObject.defineProperty(ValidatorResult.prototype, \"valid\", {\n  get: function () {\n    return !this.errors.length;\n  }\n});\n/**\n * Describes a problem with a Schema which prevents validation of an instance\n * @name SchemaError\n * @constructor\n */\n\nvar SchemaError = exports.SchemaError = function SchemaError(msg, schema) {\n  this.message = msg;\n  this.schema = schema;\n  Error.call(this, msg);\n  Error.captureStackTrace(this, SchemaError);\n};\n\nSchemaError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: SchemaError,\n    enumerable: false\n  },\n  name: {\n    value: 'SchemaError',\n    enumerable: false\n  }\n});\n\nvar SchemaContext = exports.SchemaContext = function SchemaContext(schema, options, propertyPath, base, schemas) {\n  this.schema = schema;\n  this.options = options;\n  this.propertyPath = propertyPath;\n  this.base = base;\n  this.schemas = schemas;\n};\n\nSchemaContext.prototype.resolve = function resolve(target) {\n  return uri.resolve(this.base, target);\n};\n\nSchemaContext.prototype.makeChild = function makeChild(schema, propertyName) {\n  var propertyPath = propertyName === undefined ? this.propertyPath : this.propertyPath + makeSuffix(propertyName);\n  var base = uri.resolve(this.base, schema.id || '');\n  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));\n\n  if (schema.id && !ctx.schemas[base]) {\n    ctx.schemas[base] = schema;\n  }\n\n  return ctx;\n};\n\nvar FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {\n  'date-time': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\\.\\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,\n  'date': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,\n  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,\n  'email': /^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/,\n  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,\n  'ipv6': /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/,\n  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/,\n  // hostname regex from: http://stackoverflow.com/a/1420225/5628\n  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n  'alpha': /^[a-zA-Z]+$/,\n  'alphanumeric': /^[a-zA-Z0-9]+$/,\n  'utc-millisec': function (input) {\n    return typeof input === 'string' && parseFloat(input) === parseInt(input, 10) && !isNaN(input);\n  },\n  'regex': function (input) {\n    var result = true;\n\n    try {\n      new RegExp(input);\n    } catch (e) {\n      result = false;\n    }\n\n    return result;\n  },\n  'style': /\\s*(.+?):\\s*([^;]+);?/g,\n  'phone': /^\\+(?:[0-9] ?){6,14}[0-9]$/\n};\nFORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];\n\nexports.isFormat = function isFormat(input, format, validator) {\n  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {\n    if (FORMAT_REGEXPS[format] instanceof RegExp) {\n      return FORMAT_REGEXPS[format].test(input);\n    }\n\n    if (typeof FORMAT_REGEXPS[format] === 'function') {\n      return FORMAT_REGEXPS[format](input);\n    }\n  } else if (validator && validator.customFormats && typeof validator.customFormats[format] === 'function') {\n    return validator.customFormats[format](input);\n  }\n\n  return true;\n};\n\nvar makeSuffix = exports.makeSuffix = function makeSuffix(key) {\n  key = key.toString(); // This function could be capable of outputting valid a ECMAScript string, but the\n  // resulting code for testing which form to use would be tens of thousands of characters long\n  // That means this will use the name form for some illegal forms\n\n  if (!key.match(/[.\\s\\[\\]]/) && !key.match(/^[\\d]/)) {\n    return '.' + key;\n  }\n\n  if (key.match(/^\\d+$/)) {\n    return '[' + key + ']';\n  }\n\n  return '[' + JSON.stringify(key) + ']';\n};\n\nexports.deepCompareStrict = function deepCompareStrict(a, b) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) {\n      return false;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return a.every(function (v, i) {\n      return deepCompareStrict(a[i], b[i]);\n    });\n  }\n\n  if (typeof a === 'object') {\n    if (!a || !b) {\n      return a === b;\n    }\n\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n\n    return aKeys.every(function (v) {\n      return deepCompareStrict(a[v], b[v]);\n    });\n  }\n\n  return a === b;\n};\n\nfunction deepMerger(target, dst, e, i) {\n  if (typeof e === 'object') {\n    dst[i] = deepMerge(target[i], e);\n  } else {\n    if (target.indexOf(e) === -1) {\n      dst.push(e);\n    }\n  }\n}\n\nfunction copyist(src, dst, key) {\n  dst[key] = src[key];\n}\n\nfunction copyistWithDeepMerge(target, src, dst, key) {\n  if (typeof src[key] !== 'object' || !src[key]) {\n    dst[key] = src[key];\n  } else {\n    if (!target[key]) {\n      dst[key] = src[key];\n    } else {\n      dst[key] = deepMerge(target[key], src[key]);\n    }\n  }\n}\n\nfunction deepMerge(target, src) {\n  var array = Array.isArray(src);\n  var dst = array && [] || {};\n\n  if (array) {\n    target = target || [];\n    dst = dst.concat(target);\n    src.forEach(deepMerger.bind(null, target, dst));\n  } else {\n    if (target && typeof target === 'object') {\n      Object.keys(target).forEach(copyist.bind(null, target, dst));\n    }\n\n    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));\n  }\n\n  return dst;\n}\n\n;\nmodule.exports.deepMerge = deepMerge;\n/**\n * Validates instance against the provided schema\n * Implements URI+JSON Pointer encoding, e.g. \"%7e\"=\"~0\"=>\"~\", \"~1\"=\"%2f\"=>\"/\"\n * @param o\n * @param s The path to walk o along\n * @return any\n */\n\nexports.objectGetPath = function objectGetPath(o, s) {\n  var parts = s.split('/').slice(1);\n  var k;\n\n  while (typeof (k = parts.shift()) == 'string') {\n    var n = decodeURIComponent(k.replace(/~0/, '~').replace(/~1/g, '/'));\n    if (!(n in o)) return;\n    o = o[n];\n  }\n\n  return o;\n};\n\nfunction pathEncoder(v) {\n  return '/' + encodeURIComponent(v).replace(/~/g, '%7E');\n}\n/**\n * Accept an Array of property names and return a JSON Pointer URI fragment\n * @param Array a\n * @return {String}\n */\n\n\nexports.encodePath = function encodePointer(a) {\n  // ~ must be encoded explicitly because hacks\n  // the slash is encoded by encodeURIComponent\n  return a.map(pathEncoder).join('');\n};\n/**\n * Calculate the number of decimal places a number uses\n * We need this to get correct results out of multipleOf and divisibleBy\n * when either figure is has decimal places, due to IEEE-754 float issues.\n * @param number\n * @returns {number}\n */\n\n\nexports.getDecimalPlaces = function getDecimalPlaces(number) {\n  var decimalPlaces = 0;\n  if (isNaN(number)) return decimalPlaces;\n\n  if (typeof number !== 'number') {\n    number = Number(number);\n  }\n\n  var parts = number.toString().split('e');\n\n  if (parts.length === 2) {\n    if (parts[1][0] !== '-') {\n      return decimalPlaces;\n    } else {\n      decimalPlaces = Number(parts[1].slice(1));\n    }\n  }\n\n  var decimalParts = parts[0].split('.');\n\n  if (decimalParts.length === 2) {\n    decimalPlaces += decimalParts[1].length;\n  }\n\n  return decimalPlaces;\n};","map":null,"metadata":{},"sourceType":"script"}