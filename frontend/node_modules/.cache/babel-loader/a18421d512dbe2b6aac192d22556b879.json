{"ast":null,"code":"/*\n * Copyright (c) 2019 by Filestack.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { EventEmitter } from 'eventemitter3';\nimport { S3Uploader } from './uploaders/s3';\nimport { FilestackError, FilestackErrorType } from './../../../filestack_error';\nimport { getFile } from './file_tools';\nimport { getValidator, UploadParamsSchema, StoreParamsSchema } from './../../../schema';\nvar DEFAULT_PROGRESS_INTERVAL = 1000;\n\nvar normalizeProgress = function (current, last) {\n  current.totalBytes = Math.max(current.totalBytes, last.totalBytes);\n  current.totalPercent = Math.max(current.totalPercent, last.totalPercent);\n  return current;\n};\n/**\n * Uploader main class for now its supporting only s3 upload type\n *\n * @export\n * @class Upload\n */\n\n\nvar Upload =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Upload, _super);\n\n  function Upload(options, storeOptions) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (storeOptions === void 0) {\n      storeOptions = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.options = options;\n    _this.storeOptions = storeOptions;\n    _this.lastProgress = {\n      totalBytes: 0,\n      totalPercent: 0\n    }; // do not delete filename from original options reference - copy it first\n\n    _this.storeOptions = Object.assign({}, storeOptions);\n    var validateRes = getValidator(UploadParamsSchema)(options);\n\n    if (validateRes.errors.length) {\n      throw new FilestackError(\"Invalid upload params\", validateRes.errors, FilestackErrorType.VALIDATION);\n    }\n\n    var storeValidateRes = getValidator(StoreParamsSchema)(storeOptions);\n\n    if (storeValidateRes.errors.length) {\n      throw new FilestackError(\"Invalid store upload params\", storeValidateRes.errors, FilestackErrorType.VALIDATION);\n    }\n\n    if (storeOptions.filename) {\n      _this.overwriteFileName = storeOptions.filename;\n      delete _this.storeOptions.filename;\n    }\n\n    if (_this.storeOptions.sanitizer) {\n      _this.sanitizerOptions = _this.storeOptions.sanitizer;\n      delete _this.storeOptions.sanitizer;\n    }\n\n    _this.uploader = new S3Uploader(_this.storeOptions, options.concurrency);\n\n    _this.uploader.setRetryConfig({\n      retry: options.retry || 10,\n      onRetry: options.onRetry,\n      retryFactor: options.retryFactor || 2,\n      retryMaxTime: options.retryMaxTime || 15000\n    });\n\n    _this.uploader.setTimeout(options.timeout || 120000);\n\n    if (options.partSize) {\n      _this.uploader.setPartSize(options.partSize);\n    }\n\n    if (options.intelligentChunkSize) {\n      _this.uploader.setIntelligentChunkSize(options.intelligentChunkSize);\n    }\n\n    if (options.disableIntegrityCheck) {\n      _this.uploader.setIntegrityCheck(false);\n    }\n\n    if (options.intelligent) {\n      _this.uploader.setUploadMode(options.intelligent === 'fallback' ? \"fallback\"\n      /* FALLBACK */\n      : \"intelligent\"\n      /* INTELLIGENT */\n      );\n    }\n\n    _this.uploader.on('error', function (e) {\n      return _this.emit('error', e);\n    });\n\n    _this.uploader.on('progress', _this.handleProgress.bind(_this));\n\n    return _this;\n  }\n  /**\n   * Set session object to uploader\n   *\n   * @deprecated\n   * @param {Session} session\n   * @memberof Upload\n   */\n\n\n  Upload.prototype.setSession = function (session) {\n    this.uploader.setApikey(session.apikey);\n\n    if (session.policy && session.signature) {\n      this.uploader.setSecurity({\n        policy: session.policy,\n        signature: session.signature\n      });\n    }\n\n    this.uploader.setUrl(session.urls.uploadApiUrl);\n  };\n  /**\n   * Set cancel token to controll upload flow\n   *\n   * @param {*} token\n   * @returns\n   * @memberof Upload\n   */\n\n\n  Upload.prototype.setToken = function (token) {\n    var _this = this;\n\n    if (!token || token !== Object(token)) {\n      throw new Error('Incorrect upload token. Must be instance of object');\n    }\n\n    token.pause = function () {\n      return _this.uploader.pause();\n    };\n\n    token.resume = function () {\n      return _this.uploader.resume();\n    };\n\n    token.cancel = function () {\n      return _this.uploader.abort();\n    };\n\n    return token;\n  };\n  /**\n   * Sets security to uploader instance\n   *\n   * @param {Security} security\n   * @memberof Upload\n   */\n\n\n  Upload.prototype.setSecurity = function (security) {\n    this.uploader.setSecurity(security);\n  };\n  /**\n   * Upload single file\n   *\n   * @param {(InputFile)} file\n   * @returns {Promise<any>}\n   * @memberof Upload\n   */\n\n\n  Upload.prototype.upload = function (input) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var f, res;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getFile(input, this.sanitizerOptions)];\n\n          case 1:\n            f = _a.sent();\n            f.customName = this.overwriteFileName;\n            this.uploader.addFile(f);\n            this.startProgressInterval();\n            return [4\n            /*yield*/\n            , this.uploader.execute()];\n\n          case 2:\n            res = _a.sent().shift();\n            this.stopProgressInterval();\n            this.uploader.removeAllListeners();\n\n            if (res.status === \"Failed\"\n            /* FAILED */\n            ) {\n                return [2\n                /*return*/\n                , Promise.reject(res)];\n              }\n\n            return [2\n            /*return*/\n            , Promise.resolve(res)];\n        }\n      });\n    });\n  };\n  /**\n   * Upload multiple files at once\n   *\n   * @param {(InputFile[])} input\n   * @returns {Promise<any>}\n   * @memberof Upload\n   */\n\n\n  Upload.prototype.multiupload = function (input) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a, _b, _i, i, f, res;\n\n      return tslib_1.__generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = [];\n\n            for (_b in input) _a.push(_b);\n\n            _i = 0;\n            _c.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3\n            /*break*/\n            , 4];\n            i = _a[_i];\n            /* istanbul ignore next */\n\n            if (!input.hasOwnProperty(i)) {\n              return [3\n              /*break*/\n              , 3];\n            }\n\n            return [4\n            /*yield*/\n            , getFile(input[i], this.sanitizerOptions)];\n\n          case 2:\n            f = _c.sent();\n            f.customName = this.overwriteFileName;\n            this.uploader.addFile(f);\n            _c.label = 3;\n\n          case 3:\n            _i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            this.startProgressInterval();\n            return [4\n            /*yield*/\n            , this.uploader.execute()];\n\n          case 5:\n            res = _c.sent();\n            this.stopProgressInterval();\n            return [2\n            /*return*/\n            , Promise.resolve(res)];\n        }\n      });\n    });\n  };\n  /**\n   * RUn progress with userdefined interval\n   *\n   * @private\n   * @returns\n   * @memberof Upload\n   */\n\n\n  Upload.prototype.startProgressInterval = function () {\n    var _this = this;\n\n    if (typeof this.options.onProgress !== 'function') {\n      return;\n    }\n\n    this.progressIntervalHandler = setInterval(function () {\n      _this.options.onProgress(_this.lastProgress);\n    }, this.options.progressInterval || DEFAULT_PROGRESS_INTERVAL);\n    this.options.onProgress(this.lastProgress);\n  };\n  /**\n   * Stop progress interval after upload\n   *\n   * @private\n   * @memberof Upload\n   */\n\n\n  Upload.prototype.stopProgressInterval = function () {\n    clearInterval(this.progressIntervalHandler);\n  };\n  /**\n   * Handle upload interval and normalize values\n   *\n   * @private\n   * @param {ProgressEvent} progress\n   * @memberof Upload\n   */\n\n\n  Upload.prototype.handleProgress = function (progress) {\n    // get max progress data to avoid progress jumps on any part error\n    progress = normalizeProgress(progress, this.lastProgress);\n\n    if (this.lastProgress.files) {\n      for (var i in progress.files) {\n        if (this.lastProgress.files[i]) {\n          progress.files[i] = normalizeProgress(progress.files[i], this.lastProgress.files[i]);\n        }\n      }\n    }\n\n    this.lastProgress = progress;\n  };\n\n  return Upload;\n}(EventEmitter);\n\nexport { Upload };","map":null,"metadata":{},"sourceType":"module"}