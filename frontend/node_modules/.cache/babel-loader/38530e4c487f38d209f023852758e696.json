{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('eventemitter3'); // Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\n\n\nfunction lowerBound(array, value, comp) {\n  let first = 0;\n  let count = array.length;\n\n  while (count > 0) {\n    const step = count / 2 | 0;\n    let it = first + step;\n\n    if (comp(array[it], value) <= 0) {\n      first = ++it;\n      count -= step + 1;\n    } else {\n      count = step;\n    }\n  }\n\n  return first;\n}\n\nclass PriorityQueue {\n  constructor() {\n    this._queue = [];\n  }\n\n  enqueue(run, options) {\n    options = Object.assign({\n      priority: 0\n    }, options);\n    const element = {\n      priority: options.priority,\n      run\n    };\n\n    if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n      this._queue.push(element);\n\n      return;\n    }\n\n    const index = lowerBound(this._queue, element, (a, b) => b.priority - a.priority);\n\n    this._queue.splice(index, 0, element);\n  }\n\n  dequeue() {\n    return this._queue.shift().run;\n  }\n\n  get size() {\n    return this._queue.length;\n  }\n\n}\n\nclass PQueue extends EventEmitter {\n  constructor(options) {\n    super();\n    options = Object.assign({\n      carryoverConcurrencyCount: false,\n      intervalCap: Infinity,\n      interval: 0,\n      concurrency: Infinity,\n      autoStart: true,\n      queueClass: PriorityQueue\n    }, options);\n\n    if (!(typeof options.concurrency === 'number' && options.concurrency >= 1)) {\n      throw new TypeError(\"Expected `concurrency` to be a number from 1 and up, got `\".concat(options.concurrency, \"` (\").concat(typeof options.concurrency, \")\"));\n    }\n\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(\"Expected `intervalCap` to be a number from 1 and up, got `\".concat(options.intervalCap, \"` (\").concat(typeof options.intervalCap, \")\"));\n    }\n\n    if (!(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(\"Expected `interval` to be a finite number >= 0, got `\".concat(options.interval, \"` (\").concat(typeof options.interval, \")\"));\n    }\n\n    this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n    this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n    this._intervalCount = 0;\n    this._intervalCap = options.intervalCap;\n    this._interval = options.interval;\n    this._intervalId = null;\n    this._intervalEnd = 0;\n    this._timeoutId = null;\n    this.queue = new options.queueClass(); // eslint-disable-line new-cap\n\n    this._queueClass = options.queueClass;\n    this._pendingCount = 0;\n    this._concurrency = options.concurrency;\n    this._isPaused = options.autoStart === false;\n\n    this._resolveEmpty = () => {};\n\n    this._resolveIdle = () => {};\n  }\n\n  get _doesIntervalAllowAnother() {\n    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n  }\n\n  get _doesConcurrentAllowAnother() {\n    return this._pendingCount < this._concurrency;\n  }\n\n  _next() {\n    this._pendingCount--;\n\n    this._tryToStartAnother();\n  }\n\n  _resolvePromises() {\n    this._resolveEmpty();\n\n    this._resolveEmpty = () => {};\n\n    if (this._pendingCount === 0) {\n      this._resolveIdle();\n\n      this._resolveIdle = () => {};\n    }\n  }\n\n  _onResumeInterval() {\n    this._onInterval();\n\n    this._initializeIntervalIfNeeded();\n\n    this._timeoutId = null;\n  }\n\n  _intervalPaused() {\n    const now = Date.now();\n\n    if (this._intervalId === null) {\n      const delay = this._intervalEnd - now;\n\n      if (delay < 0) {\n        // Act as the interval was done\n        // We don't need to resume it here,\n        // because it'll be resumed on line 160\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n      } else {\n        // Act as the interval is pending\n        if (this._timeoutId === null) {\n          this._timeoutId = setTimeout(() => this._onResumeInterval(), delay);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _tryToStartAnother() {\n    if (this.queue.size === 0) {\n      // We can clear the interval (\"pause\")\n      // because we can redo it later (\"resume\")\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n\n      this._resolvePromises();\n\n      return false;\n    }\n\n    if (!this._isPaused) {\n      const canInitializeInterval = !this._intervalPaused();\n\n      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n        this.emit('active');\n        this.queue.dequeue()();\n\n        if (canInitializeInterval) {\n          this._initializeIntervalIfNeeded();\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _initializeIntervalIfNeeded() {\n    if (this._isIntervalIgnored || this._intervalId !== null) {\n      return;\n    }\n\n    this._intervalId = setInterval(() => this._onInterval(), this._interval);\n    this._intervalEnd = Date.now() + this._interval;\n  }\n\n  _onInterval() {\n    if (this._intervalCount === 0 && this._pendingCount === 0) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n\n    this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\n    while (this._tryToStartAnother()) {} // eslint-disable-line no-empty\n\n  }\n\n  add(fn, options) {\n    return new Promise((resolve, reject) => {\n      const run = () => {\n        this._pendingCount++;\n        this._intervalCount++;\n\n        try {\n          Promise.resolve(fn()).then(val => {\n            resolve(val);\n\n            this._next();\n          }, err => {\n            reject(err);\n\n            this._next();\n          });\n        } catch (error) {\n          reject(error);\n\n          this._next();\n        }\n      };\n\n      this.queue.enqueue(run, options);\n\n      this._tryToStartAnother();\n    });\n  }\n\n  addAll(fns, options) {\n    return Promise.all(fns.map(fn => this.add(fn, options)));\n  }\n\n  start() {\n    if (!this._isPaused) {\n      return;\n    }\n\n    this._isPaused = false;\n\n    while (this._tryToStartAnother()) {} // eslint-disable-line no-empty\n\n  }\n\n  pause() {\n    this._isPaused = true;\n  }\n\n  clear() {\n    this.queue = new this._queueClass();\n  }\n\n  onEmpty() {\n    // Instantly resolve if the queue is empty\n    if (this.queue.size === 0) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      const existingResolve = this._resolveEmpty;\n\n      this._resolveEmpty = () => {\n        existingResolve();\n        resolve();\n      };\n    });\n  }\n\n  onIdle() {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this._pendingCount === 0 && this.queue.size === 0) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      const existingResolve = this._resolveIdle;\n\n      this._resolveIdle = () => {\n        existingResolve();\n        resolve();\n      };\n    });\n  }\n\n  get size() {\n    return this.queue.size;\n  }\n\n  get pending() {\n    return this._pendingCount;\n  }\n\n  get isPaused() {\n    return this._isPaused;\n  }\n\n}\n\nmodule.exports = PQueue;\nmodule.exports.default = PQueue;","map":null,"metadata":{},"sourceType":"script"}