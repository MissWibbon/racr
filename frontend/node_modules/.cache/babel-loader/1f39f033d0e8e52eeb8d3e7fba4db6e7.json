{"ast":null,"code":"var _this = this;\n\nimport * as tslib_1 from \"tslib\";\n/*\n * Copyright (c) 2019 by Filestack.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { File as FsFile } from './file';\nimport { isNode, requireNode, getMimetype } from './../../utils';\nimport { FilestackError } from './../../../filestack_error';\nimport fileType from 'file-type';\nvar base64Regexp = /data:([a-zA-Z]*\\/[a-zA-Z]*);base64,([^\\\"]*)/i;\n/**\n * Check if file is buffer\n *\n * @node\n * @param input\n */\n\nvar isFileBuffer = function (input) {\n  return Buffer.isBuffer(input);\n};\n/**\n * Check if file is blob\n * @param input\n */\n\n\nvar isFileBlob = function (input) {\n  return input.toString() === '[object Blob]';\n};\n/**\n * Check if input is instance of browser file\n *\n * @browser\n * @param input\n */\n\n\nvar isFileBrowser = function (input) {\n  return input instanceof File;\n};\n/**\n * Check if file is base64 string\n *\n * @param input\n */\n\n\nvar isFileBase = function (input) {\n  if (typeof input !== 'string') {\n    return false;\n  }\n\n  if (input.indexOf('base64') > -1) {\n    input = input.match(base64Regexp).pop();\n  }\n\n  if (isNode()) {\n    if (Buffer.from(input, 'base64').toString('base64') === input) {\n      return true;\n    }\n\n    return false;\n  }\n\n  try {\n    return btoa(atob(input)) === input;\n  } catch (err) {\n    /* istanbul ignore next */\n    return false;\n  }\n};\n/**\n * Check if file is instance of named interface\n *\n * @param input\n */\n\n\nvar isFileNamed = function (input) {\n  return input && input['file'] && input['name'];\n};\n/**\n * Check if input is a valid file path\n *\n * @node\n * @param input\n */\n\n\nvar isFilePath = function (input) {\n  return requireNode('fs').existsSync(input);\n};\n/**\n * Convert encoded base64 string or dataURI to blob\n *\n * @browser\n * @param b64data     String to decode\n * @param sliceSize   Byte quantity to split data into\n * @private\n * @returns {Blob}\n */\n\n\nvar b64toBlob = function (b64Data, sliceSize) {\n  if (sliceSize === void 0) {\n    sliceSize = 512;\n  }\n\n  var contentType = '';\n\n  if (b64Data.indexOf('base64') > -1) {\n    var matches = b64Data.match(base64Regexp);\n    b64Data = matches.pop();\n    contentType = matches[1];\n  }\n\n  var byteCharacters = atob(b64Data);\n  var byteArrays = [];\n\n  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {\n    var slice = byteCharacters.slice(offset, offset + sliceSize);\n    var byteNumbers = new Array(slice.length);\n\n    for (var i = 0; i < slice.length; i += 1) {\n      byteNumbers[i] = slice.charCodeAt(i);\n    }\n\n    byteArrays.push(new Uint8Array(byteNumbers));\n  }\n\n  return new Blob(byteArrays, {\n    type: contentType\n  });\n};\n/**\n * Read file as array buffer\n *\n * @browser\n * @private\n * @param blob\n * @returns {Boolean}\n */\n\n\nvar readFile = function (file) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    return tslib_1.__generator(this, function (_a) {\n      /* istanbul ignore next */\n      if (!File || !FileReader || !Blob) {\n        return [2\n        /*return*/\n        , Promise.reject(new FilestackError('The File APIs are not fully supported by your browser'))];\n      }\n\n      return [2\n      /*return*/\n      , Promise.resolve({\n        slice: function (start, end) {\n          return readPart(start, end, file);\n        },\n        release: function () {\n          file = null;\n        }\n      })];\n    });\n  });\n};\n/**\n * Read file par instead of whole file to avoid browser crashing\n *\n * @param start - star byte\n * @param end  - end byte\n * @param file - file to slice\n */\n\n\nvar readPart = function (start, end, file) {\n  return new Promise(function (resolve, reject) {\n    var r = new FileReader();\n    var blob = file.slice(start, end);\n\n    r.onload = function () {\n      return resolve(r.result);\n    };\n\n    r.onerror = reject;\n    r.readAsArrayBuffer(blob);\n  });\n}; // =================== BROWSER UTILS ===================\n\n/**\n * Accepts b64string or blob file\n *\n * @browser\n * @param {*} fileOrString\n * @returns {Promise<File>}\n */\n\n\nvar getFileBrowser = function (input, sanitizeOptions) {\n  var filename;\n  var file;\n\n  if (isFileNamed(input)) {\n    filename = input.name;\n    input = input.file;\n  }\n\n  if (isFileBrowser(input)) {\n    file = input;\n    filename = input.name;\n  } else if (isFileBase(input)) {\n    file = b64toBlob(input);\n  } else if (isFileBlob(input)) {\n    file = input;\n  } else {\n    return Promise.reject(new FilestackError('Unsupported input file type'));\n  }\n\n  return readFile(file).then(function (res) {\n    return tslib_1.__awaiter(_this, void 0, void 0, function () {\n      var mime, _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            mime = file.type;\n            if (!!file.type) return [3\n            /*break*/\n            , 2];\n            _a = getMimetype;\n            return [4\n            /*yield*/\n            , res.slice(0, fileType.minimumBytes)];\n\n          case 1:\n            mime = _a.apply(void 0, [_b.sent(), filename]);\n            _b.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , new FsFile({\n              name: filename,\n              size: file.size,\n              type: mime,\n              slice: res.slice,\n              release: res.release\n            }, sanitizeOptions)];\n        }\n      });\n    });\n  });\n}; // =================== NODE UTILS ===================\n\n/**\n * Accepts Buffer or filepath or base64 string\n *\n * @node\n * @param {*} inputFile\n * @returns {Promise<File>}\n */\n\n\nvar getFileNode = function (input, sanitizeOptions) {\n  var filename;\n\n  if (isFileNamed(input)) {\n    filename = input.name;\n    input = input.file;\n  }\n\n  if (isFilePath(input)) {\n    var path_1 = input; // @todo improve slicer open file and read it py by part\n\n    return new Promise(function (resolve, reject) {\n      return requireNode('fs').readFile(path_1, function (err, buffer) {\n        if (err) {\n          return reject(err);\n        }\n\n        if (!filename) {\n          filename = requireNode('path').basename(path_1);\n        }\n\n        return resolve(new FsFile({\n          name: filename,\n          size: buffer.byteLength,\n          type: getMimetype(buffer, filename),\n          slice: function (start, end) {\n            return Promise.resolve(buffer.slice(start, end));\n          }\n        }, sanitizeOptions));\n      });\n    });\n  }\n\n  if (isFileBase(input)) {\n    input = Buffer.from(input, 'base64');\n  }\n\n  if (isFileBuffer(input)) {\n    return Promise.resolve(new FsFile({\n      name: filename,\n      size: input.byteLength,\n      type: getMimetype(input, filename),\n      // @ts-ignore\n      slice: function (start, end) {\n        return Promise.resolve(input.slice(start, end));\n      }\n    }, sanitizeOptions));\n  }\n\n  return Promise.reject(new FilestackError('Unsupported input file type'));\n};\n\nexport var getFile = function (input, sanitizeOptions) {\n  return isNode() ? getFileNode(input, sanitizeOptions) : getFileBrowser(input, sanitizeOptions);\n};","map":null,"metadata":{},"sourceType":"module"}