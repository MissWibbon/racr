{"ast":null,"code":"/*\n * Copyright (c) 2018 by Filestack.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { request } from './request';\nimport { removeEmpty } from '../utils';\nimport { FilestackError } from './../../filestack_error';\nimport { getValidator, MetadataParamsSchema, RetrieveParamsSchema } from './../../schema';\n/**\n * Remove given file\n *\n * @private\n * @param session\n * @param handle\n * @param security\n */\n\nexport var remove = function (session, handle, skipStorage, security) {\n  if (!handle || typeof handle !== 'string') {\n    throw new FilestackError('A valid Filestack handle is required for remove');\n  }\n\n  if (!(session.policy && session.signature) && (!security || !(security.policy && security.signature))) {\n    throw new FilestackError('Security policy and signature are required for remove');\n  }\n\n  var fileApiUrl = session.urls.fileApiUrl;\n  var baseURL = fileApiUrl + \"/\" + handle;\n  var options = {\n    key: session.apikey,\n    policy: security && security.policy || session.policy,\n    signature: security && security.signature || session.signature\n  };\n\n  if (skipStorage) {\n    options.skip_storage = true;\n  }\n\n  return request.delete(baseURL, {\n    params: removeEmpty(options)\n  });\n};\n/**\n * Returns file metadata\n *\n * @private\n * @param session\n * @param handle\n * @param opts\n * @param security\n */\n\nexport var metadata = function (session, handle, opts, security) {\n  if (!handle || typeof handle !== 'string') {\n    throw new FilestackError('A valid Filestack handle is required for metadata');\n  }\n\n  var validateRes = getValidator(MetadataParamsSchema)(opts);\n\n  if (validateRes.errors.length) {\n    throw new FilestackError(\"Invalid metadata params\", validateRes.errors);\n  }\n\n  var options = tslib_1.__assign({}, opts);\n\n  options.source_url = options.sourceUrl; // source_url is snake_case\n\n  options.policy = security && security.policy || session.policy;\n  options.signature = security && security.signature || session.signature;\n  var baseURL = session.urls.fileApiUrl + \"/\" + handle + \"/metadata\";\n  return new Promise(function (resolve, reject) {\n    request.get(baseURL, {\n      params: removeEmpty(options)\n    }).then(function (res) {\n      return resolve(tslib_1.__assign({}, res.data, {\n        handle: handle\n      }));\n    }).catch(reject);\n  });\n};\n/**\n * @private\n */\n\nvar ERequestMethod;\n\n(function (ERequestMethod) {\n  ERequestMethod[\"get\"] = \"get\";\n  ERequestMethod[\"head\"] = \"head\";\n})(ERequestMethod || (ERequestMethod = {}));\n/**\n * @private\n */\n\n\nvar EResponseType;\n\n(function (EResponseType) {\n  EResponseType[\"blob\"] = \"blob\";\n  EResponseType[\"json\"] = \"json\";\n})(EResponseType || (EResponseType = {}));\n/**\n * Returns file information\n *\n * @private\n * @param session\n * @param handle\n * @param options\n * @param security\n */\n\n\nexport var retrieve = function (session, handle, options, security) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!handle || handle.length === 0 || typeof handle !== 'string') {\n    throw new FilestackError('File handle is required');\n  }\n\n  var validateRes = getValidator(RetrieveParamsSchema)(options);\n\n  if (validateRes.errors.length) {\n    throw new FilestackError(\"Invalid retrieve params\", validateRes.errors);\n  }\n\n  var requestOptions = tslib_1.__assign({}, options);\n\n  requestOptions.key = session.apikey;\n  requestOptions.policy = security && security.policy || session.policy;\n  requestOptions.signature = security && security.signature || session.signature;\n  var method = ERequestMethod.get;\n\n  if (requestOptions.head) {\n    method = ERequestMethod.head;\n    delete requestOptions.head;\n  }\n\n  var extension;\n\n  if (requestOptions.extension && requestOptions.extension.length) {\n    extension = requestOptions.extension;\n    delete requestOptions.extension;\n  }\n\n  var metadata;\n\n  if (requestOptions.metadata) {\n    if (method === ERequestMethod.head) {\n      throw new FilestackError('Head and metadata options cannot be used together');\n    }\n\n    metadata = requestOptions.metadata;\n    delete requestOptions.metadata;\n  }\n\n  var baseURL = session.urls.fileApiUrl + \"/\" + handle + (extension ? \"+\" + extension : '') + (metadata ? '/metadata' : '');\n  return new Promise(function (resolve, reject) {\n    request({\n      url: baseURL,\n      method: method,\n      params: removeEmpty(requestOptions)\n    }).then(function (res) {\n      return resolve(method === ERequestMethod.head ? res.headers : res.data);\n    }).catch(reject);\n  });\n};","map":null,"metadata":{},"sourceType":"module"}