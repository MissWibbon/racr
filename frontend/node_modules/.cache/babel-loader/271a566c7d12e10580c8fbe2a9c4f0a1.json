{"ast":null,"code":"/*\n * Copyright (c) 2018 by Filestack.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Debug from 'debug';\nimport axios from 'axios';\nimport { uniqueId, getVersion } from '../utils';\nvar debug = Debug('fs:request');\nvar RESPONSE_DEBUG_PREFIX = 'x-filestack-';\n/**\n *\n * @private\n * @param method\n * @param url\n */\n\nexport var requestWithSource = function (retryConfig) {\n  var axiosInstance = axios.create({\n    headers: {\n      'filestack-source': getVersion(),\n      'filestack-trace-id': Math.floor(Date.now() / 1000) + \"-\" + uniqueId(),\n      'filestack-trace-span': \"jssdk-\" + uniqueId()\n    }\n  });\n\n  if (retryConfig) {\n    useRetryPolicy(axiosInstance, retryConfig);\n  }\n\n  useDebugInterceptor(axiosInstance);\n  return axiosInstance;\n};\nexport var postWithRetry = function (url, fields, config, retryConfig) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  debug(\"[RequestWithRetry] set fields %O for url \" + url, fields);\n\n  if (!config.headers) {\n    config.headers = {};\n  }\n\n  config.headers = Object.assign({}, config.headers, {\n    'filestack-source': getVersion(),\n    'filestack-trace-id': Math.floor(Date.now() / 1000) + \"-\" + uniqueId(),\n    'filestack-trace-span': \"jssdk-\" + uniqueId()\n  });\n  var axiosInstance = axios.create();\n\n  if (retryConfig) {\n    useRetryPolicy(axiosInstance, retryConfig);\n  }\n\n  useDebugInterceptor(axiosInstance);\n  return axiosInstance.post(url, fields, config);\n};\nexport var shouldRetry = function (err) {\n  // we always should retry on network failure\n  switch (err.code) {\n    case 'ECONNRESET':\n    case 'ETIMEDOUT':\n    case 'EADDRINUSE':\n    case 'ESOCKETTIMEDOUT':\n    case 'EPIPE':\n      return true;\n  } // if request was not made and there is no response - retry\n\n\n  if (!err.response) {\n    return true;\n  } // we should retry on all server errors (5xx)\n\n\n  if (500 <= err.response.status && err.response.status <= 599) {\n    return true;\n  } // we should not retry on other errors (4xx) ie: BadRequest etc\n\n\n  return false;\n};\n\nvar useDebugInterceptor = function (instance) {\n  /* istanbul ignore next */\n  // this is internal debug method\n  instance.interceptors.response.use(function (resp) {\n    if (debug.enabled) {\n      for (var i in resp.headers) {\n        if (!resp.headers.hasOwnProperty(resp.headers) && i.indexOf(RESPONSE_DEBUG_PREFIX) === -1) {\n          continue;\n        }\n\n        debug(\"Filestack Response Debug Header - \" + i + \": \" + resp.headers[i]);\n      }\n    }\n\n    return resp;\n  });\n};\n\nexport var useRetryPolicy = function (instance, retryConfig) {\n  instance.interceptors.request.use(function (config) {\n    var currentState = config['retry'] || {};\n    currentState.retryCount = currentState.retryCount || 0;\n    config['retry'] = currentState;\n    return config;\n  });\n  return instance.interceptors.response.use(null, function (err) {\n    var requestConfig = err.config;\n\n    if (axios.isCancel(err)) {\n      debug('[Retry] Upload canceled by user');\n      return Promise.reject(err);\n    }\n\n    debug(\"[Retry] Start retry process code: \" + err.code + \", %O\", err);\n    /* istanbul ignore next */\n\n    if (!requestConfig) {\n      debug(\"[Retry] Retry config not found, Rejecting request\");\n      return Promise.reject(err);\n    }\n\n    var state = requestConfig.retry;\n\n    if (!shouldRetry(err)) {\n      debug(\"[Retry] Response code not allowing to retry\");\n      return Promise.reject(err);\n    }\n\n    requestConfig.retry.retryCount += 1;\n\n    if (requestConfig.retry.retryCount > retryConfig.retry) {\n      debug(\"[Retry] Max retry count reached \" + requestConfig.retry.retryCount);\n      return Promise.reject(err);\n    }\n\n    var retryDelay = Math.max(Math.min(retryConfig.retryMaxTime, Math.pow(retryConfig.retryFactor, state.retryCount) * 1000), 1);\n    debug(\"[Retry] Retrying request to \" + requestConfig.url + \", count \" + state.retryCount + \" of \" + retryConfig.retry + \" - Delay: \" + retryDelay);\n    return new Promise(function (resolve) {\n      return setTimeout(function () {\n        if (typeof retryConfig.onRetry === 'function') {\n          retryConfig.onRetry.call(instance, requestConfig);\n        }\n\n        resolve(instance(requestConfig));\n      }, retryDelay);\n    });\n  });\n}; // set global debug inspector\n\nuseDebugInterceptor(axios);\nexport { axios as request };","map":null,"metadata":{},"sourceType":"module"}